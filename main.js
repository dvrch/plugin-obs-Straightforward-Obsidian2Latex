/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StraightforwardObsidian2LatexPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/converter/LatexConverter.ts
var import_obsidian = require("obsidian");

// src/converter/processors/MarkdownProcessor.ts
var MarkdownProcessor = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Traite les lignes markdown et les convertit en LaTeX
   */
  async process(lines) {
    let processedLines = [...lines];
    processedLines = this.processHeaders(processedLines);
    processedLines = this.processLists(processedLines);
    processedLines = this.processFormatting(processedLines);
    processedLines = this.processLinks(processedLines);
    processedLines = this.processComments(processedLines);
    processedLines = this.processSpecialSymbols(processedLines);
    return processedLines;
  }
  /**
   * Traite les en-têtes markdown
   */
  processHeaders(lines) {
    return lines.map((line) => {
      line = line.replace(/^# (.*)$/, "\\section{$1}");
      line = line.replace(/^## (.*)$/, "\\subsection{$1}");
      line = line.replace(/^### (.*)$/, "\\subsubsection{$1}");
      line = line.replace(/^#### (.*)$/, "\\paragraph{$1} \\hspace{0pt} \\\\");
      line = line.replace(/^##### (.*)$/, "\\paragraph{$1} \\hspace{0pt} \\\\");
      line = line.replace(/^###### (.*)$/, "\\paragraph{$1} \\hspace{0pt} \\\\");
      line = line.replace(/^####### (.*)$/, "\\paragraph{$1} \\hspace{0pt} \\\\");
      line = line.replace(/^######## (.*)$/, "\\paragraph{$1} \\hspace{0pt} \\\\");
      line = line.replace(/^# Appendix$/, "\\appendix");
      return line;
    });
  }
  /**
   * Traite les listes
   */
  processLists(lines) {
    const processedLines = [];
    let inList = false;
    let listType = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.match(/^[\s]*[-*+]\s/)) {
        if (!inList) {
          processedLines.push("\\begin{itemize}");
          inList = true;
          listType = "itemize";
        }
        const item = line.replace(/^[\s]*[-*+]\s/, "");
        processedLines.push(`\\item ${item}`);
      } else if (line.match(/^[\s]*\d+\.\s/)) {
        if (!inList) {
          processedLines.push("\\begin{enumerate}");
          inList = true;
          listType = "enumerate";
        }
        const item = line.replace(/^[\s]*\d+\.\s/, "");
        processedLines.push(`\\item ${item}`);
      } else if (inList && line.trim() === "") {
        processedLines.push(`\\end{${listType}}`);
        inList = false;
        listType = "";
      } else {
        if (inList) {
          processedLines.push(`\\end{${listType}}`);
          inList = false;
          listType = "";
        }
        processedLines.push(line);
      }
    }
    if (inList) {
      processedLines.push(`\\end{${listType}}`);
    }
    return processedLines;
  }
  /**
   * Traite le formatage (gras, italique, etc.)
   */
  processFormatting(lines) {
    return lines.map((line) => {
      line = line.replace(/\*\*(.*?)\*\*/g, "\\textbf{$1}");
      line = line.replace(/\*(.*?)\*/g, "\\textit{$1}");
      line = line.replace(/==(.*?)==/g, "\\hl{$1}");
      line = line.replace(/~~(.*?)~~/g, "\\st{$1}");
      line = line.replace(/`(.*?)`/g, "\\texttt{$1}");
      line = line.replace(/#(\S+)/g, "\\texttt{$1}");
      return line;
    });
  }
  /**
   * Traite les liens
   */
  processLinks(lines) {
    return lines.map((line) => {
      line = line.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "\\href{$2}{$1}");
      line = line.replace(/(https?:\/\/\S+)/g, "\\url{$1}");
      return line;
    });
  }
  /**
   * Traite les commentaires
   */
  processComments(lines) {
    return lines.filter((line) => {
      return !line.trim().startsWith("%%");
    });
  }
  /**
   * Traite les symboles spéciaux
   */
  processSpecialSymbols(lines) {
    return lines.map((line) => {
      line = line.replace(/%/g, "\\%");
      line = line.replace(/#/g, "\\#");
      line = line.replace(/\$/g, "\\$");
      line = line.replace(/\{/g, "\\{");
      line = line.replace(/\}/g, "\\}");
      line = line.replace(/\^/g, "\\^{}");
      line = line.replace(/\~/g, "\\~{}");
      line = line.replace(/\\/g, "\\textbackslash{}");
      line = line.replace(/&/g, "\\&");
      return line;
    });
  }
};

// src/converter/processors/EquationProcessor.ts
var EquationProcessor = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Traite les équations dans les lignes
   */
  async process(lines) {
    let processedLines = [...lines];
    processedLines = this.processInlineEquations(processedLines);
    processedLines = this.processBlockEquations(processedLines);
    processedLines = this.processAlignedEquations(processedLines);
    processedLines = this.processEquationReferences(processedLines);
    return processedLines;
  }
  /**
   * Traite les équations inline ($...$)
   */
  processInlineEquations(lines) {
    return lines.map((line) => {
      line = line.replace(/\$([^$]+)\$/g, "\\($1\\)");
      return line;
    });
  }
  /**
   * Traite les équations en bloc ($$...$$)
   */
  processBlockEquations(lines) {
    const processedLines = [];
    let inEquation = false;
    let equationContent = [];
    let equationLabel = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes("$$") && !inEquation) {
        inEquation = true;
        equationContent = [];
        const match = line.match(/\$\$(.*?)\$\$/);
        if (match) {
          equationContent.push(match[1]);
          const labelMatch = line.match(/\\label\{eq__block_([^}]+)\}/);
          if (labelMatch) {
            equationLabel = labelMatch[1];
          }
        }
      } else if (line.includes("$$") && inEquation) {
        inEquation = false;
        const match = line.match(/\$\$(.*?)\$\$/);
        if (match) {
          equationContent.push(match[1]);
        }
        const latexEquation = this.generateLatexEquation(equationContent.join("\n"), equationLabel);
        processedLines.push(latexEquation);
        equationContent = [];
        equationLabel = "";
      } else if (inEquation) {
        equationContent.push(line);
      } else {
        processedLines.push(line);
      }
    }
    return processedLines;
  }
  /**
   * Traite les équations alignées
   */
  processAlignedEquations(lines) {
    return lines.map((line) => {
      line = line.replace(
        /\$\$\s*\\begin\{aligned\}(.*?)\\end\{aligned\}\s*\$\$/gs,
        (match, content) => {
          return this.convertAlignedToSplit(content);
        }
      );
      line = line.replace(
        /\$\$\s*\\begin\{align\}(.*?)\\end\{align\}\s*\$\$/gs,
        (match, content) => {
          return this.convertAlignToSplit(content);
        }
      );
      return line;
    });
  }
  /**
   * Convertit une équation alignée en format split
   */
  convertAlignedToSplit(content) {
    const lines = content.split("\\\\").map((line) => line.trim());
    const splitContent = lines.map((line) => `		${line}`).join(" \\\\\n");
    return `\\begin{equation}
	\\begin{split}
${splitContent}
	\\end{split}
\\end{equation}`;
  }
  /**
   * Convertit une équation align en format split
   */
  convertAlignToSplit(content) {
    const lines = content.split("\\\\").map((line) => line.trim());
    const splitContent = lines.map((line) => `		${line}`).join(" \\\\\n");
    return `\\begin{equation}
	\\begin{split}
${splitContent}
	\\end{split}
\\end{equation}`;
  }
  /**
   * Traite les références d'équations
   */
  processEquationReferences(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[eq__block_([^\]]+)\]\]/g, "\\eqref{eq:$1}");
      line = line.replace(/\\ref\{eq__block_([^}]+)\}/g, "\\ref{eq:$1}");
      return line;
    });
  }
  /**
   * Génère une équation LaTeX à partir du contenu
   */
  generateLatexEquation(content, label) {
    content = content.trim();
    content = content.replace(/^\$\$|\$\$$/g, "").trim();
    const labelPart = label ? ` \\label{eq:${label}}` : "";
    return `\\begin{equation}${labelPart}
	${content}
\\end{equation}`;
  }
  /**
   * Convertit les équations non numérotées en numérotées
   */
  convertNonNumberedToNumbered(lines) {
    return lines.map((line) => {
      const match = line.match(/\$\$\s*(.*?)\s*\$\$\s*\\label\{eq__block_([^}]+)\}/);
      if (match) {
        const equation = match[1].trim();
        const label = match[2];
        return `\\begin{equation} \\label{eq:${label}}
	${equation}
\\end{equation}`;
      }
      return line;
    });
  }
  /**
   * Vérifie et corrige les équations alignées
   */
  checkAndCorrectAlignedEquations(lines) {
    return lines.map((line) => {
      if (line.includes("\\begin{aligned}") || line.includes("\\begin{align}")) {
      }
      return line;
    });
  }
};

// src/converter/processors/TableProcessor.ts
var TableProcessor = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Traite les tableaux dans les lignes
   */
  async process(lines) {
    let processedLines = [...lines];
    const tableIndexes = this.identifyTables(processedLines);
    processedLines = this.convertTables(processedLines, tableIndexes);
    return processedLines;
  }
  /**
   * Identifie les tableaux dans les lignes
   */
  identifyTables(lines) {
    const tableIndexes = [];
    let tableStarted = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isTableLine = this.isTableLine(line);
      if (isTableLine && !tableStarted) {
        tableStarted = true;
        tableIndexes.push(i);
      } else if (!isTableLine && tableStarted) {
        tableStarted = false;
        tableIndexes.push(i);
      }
    }
    if (tableStarted) {
      tableIndexes.push(lines.length);
    }
    return tableIndexes;
  }
  /**
   * Vérifie si une ligne fait partie d'un tableau
   */
  isTableLine(line) {
    return line.includes("|") && line.trim().length > 0;
  }
  /**
   * Convertit les tableaux identifiés
   */
  convertTables(lines, tableIndexes) {
    const processedLines = [];
    let tableIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (tableIndex < tableIndexes.length && i === tableIndexes[tableIndex]) {
        const startIndex = i;
        const endIndex = tableIndexes[tableIndex + 1];
        const tableLines = lines.slice(startIndex, endIndex);
        const latexTable = this.convertTableToLatex(tableLines);
        processedLines.push(latexTable);
        i = endIndex - 1;
        tableIndex += 2;
      } else if (tableIndex < tableIndexes.length && i === tableIndexes[tableIndex + 1]) {
        continue;
      } else {
        processedLines.push(lines[i]);
      }
    }
    return processedLines;
  }
  /**
   * Convertit un tableau markdown en LaTeX
   */
  convertTableToLatex(tableLines) {
    if (tableLines.length < 2) {
      return tableLines.join("\n");
    }
    const rows = [];
    let headers = [];
    let alignments = [];
    for (let i = 0; i < tableLines.length; i++) {
      const line = tableLines[i].trim();
      if (line.length === 0) continue;
      const columns = line.split("|").map((col) => col.trim()).filter((col) => col.length > 0);
      if (i === 0) {
        headers = columns;
      } else if (i === 1) {
        alignments = this.parseAlignments(columns);
      } else {
        rows.push(columns);
      }
    }
    return this.generateLatexTable(headers, alignments, rows);
  }
  /**
   * Parse les alignements depuis la ligne de séparateurs
   */
  parseAlignments(alignmentLine) {
    return alignmentLine.map((col) => {
      col = col.trim();
      if (col.startsWith(":") && col.endsWith(":")) {
        return "c";
      } else if (col.startsWith(":")) {
        return "l";
      } else if (col.endsWith(":")) {
        return "r";
      } else {
        return "l";
      }
    });
  }
  /**
   * Génère le tableau LaTeX
   */
  generateLatexTable(headers, alignments, rows) {
    const packageType = this.settings.getTablePackage();
    const alignment = this.settings.getTableAlignment();
    const relWidth = this.settings.getTableRelWidth();
    const columnSpec = alignments.map((align) => {
      switch (align) {
        case "l":
          return "l";
        case "r":
          return "r";
        case "c":
          return "c";
        default:
          return "l";
      }
    }).join("");
    const headerRow = headers.map((header) => this.escapeLatex(header)).join(" & ");
    const dataRows = rows.map((row) => {
      return row.map((cell) => this.escapeLatex(cell)).join(" & ");
    });
    if (packageType === "tabularx") {
      return this.generateTabularxTable(columnSpec, headerRow, dataRows, relWidth);
    } else if (packageType === "longtable") {
      return this.generateLongtableTable(columnSpec, headerRow, dataRows);
    } else {
      return this.generateStandardTable(columnSpec, headerRow, dataRows);
    }
  }
  /**
   * Génère un tableau avec tabularx
   */
  generateTabularxTable(columnSpec, headerRow, dataRows, relWidth) {
    const width = relWidth > 0 ? `${relWidth}\\linewidth` : "\\linewidth";
    return `\\begin{table}[h]
\\centering
\\begin{tabularx}{${width}}{${columnSpec}}
\\hline
${headerRow} \\\\
\\hline
${dataRows.join(" \\\\\n")} \\\\
\\hline
\\end{tabularx}
\\caption{Caption du tableau}
\\label{tab:table_label}
\\end{table}`;
  }
  /**
   * Génère un tableau avec longtable
   */
  generateLongtableTable(columnSpec, headerRow, dataRows) {
    return `\\begin{longtable}{${columnSpec}}
\\hline
${headerRow} \\\\
\\hline
\\endfirsthead
\\hline
${headerRow} \\\\
\\hline
\\endhead
\\hline
\\endfoot
${dataRows.join(" \\\\\n")} \\\\
\\hline
\\caption{Caption du tableau}
\\label{tab:table_label}
\\end{longtable}`;
  }
  /**
   * Génère un tableau standard
   */
  generateStandardTable(columnSpec, headerRow, dataRows) {
    return `\\begin{table}[h]
\\centering
\\begin{tabular}{${columnSpec}}
\\hline
${headerRow} \\\\
\\hline
${dataRows.join(" \\\\\n")} \\\\
\\hline
\\end{tabular}
\\caption{Caption du tableau}
\\label{tab:table_label}
\\end{table}`;
  }
  /**
   * Échappe les caractères spéciaux LaTeX
   */
  escapeLatex(text) {
    return text.replace(/\\/g, "\\textbackslash{}").replace(/\{/g, "\\{").replace(/\}/g, "\\}").replace(/\$/g, "\\$").replace(/\^/g, "\\^{}").replace(/\~/g, "\\~{}").replace(/\&/g, "\\&").replace(/%/g, "\\%").replace(/#/g, "\\#").replace(/_/g, "\\_");
  }
};

// src/converter/processors/ReferenceProcessor.ts
var ReferenceProcessor = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Traite les références dans les lignes
   */
  async process(lines) {
    let processedLines = [...lines];
    processedLines = this.processInternalLinks(processedLines);
    processedLines = this.processCitations(processedLines);
    if (this.settings.getConvertNonEmbeddedReferences()) {
      processedLines = this.processNonEmbeddedReferences(processedLines);
    }
    processedLines = this.processFigureReferences(processedLines);
    processedLines = this.processTableReferences(processedLines);
    return processedLines;
  }
  /**
   * Traite les liens internes [[note]]
   */
  processInternalLinks(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[([^\]]+)\]\]/g, (match, noteName) => {
        if (this.isCitation(noteName)) {
          return `\\cite{${noteName}}`;
        }
        return `\\ref{${this.normalizeLabel(noteName)}}`;
      });
      line = line.replace(/\[\[([^\]]+)#([^\]]+)\]\]/g, (match, noteName, sectionName) => {
        const label = this.normalizeLabel(noteName);
        const sectionLabel = this.normalizeLabel(sectionName);
        return `\\ref{${label}:${sectionLabel}}`;
      });
      return line;
    });
  }
  /**
   * Traite les citations [[p1]], [[p2]], etc.
   */
  processCitations(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[p(\d+)\]\]/g, "\\cite{p$1}");
      line = line.replace(/\[\[ref(\d+)\]\]/g, "\\cite{ref$1}");
      return line;
    });
  }
  /**
   * Traite les références non-embarquées
   */
  processNonEmbeddedReferences(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[([^\]]+)\]\]/g, "$1");
      return line;
    });
  }
  /**
   * Traite les références de figures
   */
  processFigureReferences(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[figure__block_([^\]]+)\]\]/g, "\\ref{fig:$1}");
      line = line.replace(/\\ref\{figure__block_([^}]+)\}/g, "\\ref{fig:$1}");
      return line;
    });
  }
  /**
   * Traite les références de tableaux
   */
  processTableReferences(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[table__block_([^\]]+)\]\]/g, "\\ref{tab:$1}");
      line = line.replace(/\\ref\{table__block_([^}]+)\}/g, "\\ref{tab:$1}");
      return line;
    });
  }
  /**
   * Vérifie si une référence est une citation
   */
  isCitation(noteName) {
    const citationPattern = /^(p|ref)\d+$/;
    return citationPattern.test(noteName);
  }
  /**
   * Normalise un label pour LaTeX
   */
  normalizeLabel(label) {
    return label.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
  }
  /**
   * Trouve une note par son nom
   */
  async findNoteByName(noteName) {
    const files = this.app.vault.getMarkdownFiles();
    let file = files.find((f) => f.basename === noteName);
    if (file) return file;
    file = files.find((f) => f.name === `${noteName}.md`);
    if (file) return file;
    file = files.find((f) => f.path.includes(noteName));
    return file || null;
  }
  /**
   * Obtient le contenu d'une note
   */
  async getNoteContent(noteName) {
    const file = await this.findNoteByName(noteName);
    if (!file) return null;
    try {
      return await this.app.vault.read(file);
    } catch (error) {
      console.error(`Erreur lors de la lecture de ${noteName}:`, error);
      return null;
    }
  }
  /**
   * Traite les références avec numéros de section
   */
  processSectionReferences(lines) {
    if (!this.settings.getAddSectionNumberAfterReferencing()) {
      return lines;
    }
    return lines.map((line) => {
      line = line.replace(/\\ref\{([^}]+)\}/g, (match, label) => {
        return `${match} (section)`;
      });
      return line;
    });
  }
  /**
   * Traite les références croisées entre sections
   */
  processCrossReferences(lines) {
    return lines.map((line) => {
      line = line.replace(/\[\[([^#]+)#([^\]]+)\]\]/g, (match, section, subsection) => {
        const sectionLabel = this.normalizeLabel(section);
        const subsectionLabel = this.normalizeLabel(subsection);
        return `\\ref{${sectionLabel}:${subsectionLabel}}`;
      });
      return line;
    });
  }
};

// src/converter/generators/LatexGenerator.ts
var LatexGenerator = class {
  constructor(app, settings, pathManager) {
    this.app = app;
    this.settings = settings;
    this.pathManager = pathManager;
  }
  /**
   * Génère le contenu LaTeX complet
   */
  async generate(lines, file) {
    const preamble = this.generatePreamble();
    const documentStart = this.generateDocumentStart();
    const mainContent = this.processMainContent(lines);
    const documentEnd = this.generateDocumentEnd();
    return preamble + "\n\n" + documentStart + "\n\n" + mainContent + "\n\n" + documentEnd;
  }
  /**
   * Génère le préambule LaTeX
   */
  generatePreamble() {
    const documentClass = this.settings.getDocumentClass();
    const fontSize = this.settings.getFontSize();
    const fontsizeOption = fontSize ? `[${fontSize}]` : "";
    let preamble = `\\documentclass${fontsizeOption}{${documentClass}}`;
    preamble += "\n\\usepackage[table]{xcolor}";
    preamble += "\n\\usepackage{tabularx}";
    preamble += "\n\\usepackage{longtable}";
    preamble += "\n\\usepackage{tabularray}";
    preamble += "\n\\usepackage{enumitem,amssymb}";
    preamble += "\n\\usepackage{hyperref}";
    preamble += "\n\\usepackage{geometry}";
    preamble += "\n\\usepackage{cleveref}";
    preamble += "\n\\newlist{todolist}{itemize}{2}";
    preamble += "\n\\setlist[todolist]{label=$\\square$}";
    preamble += "\n\\newtotcounter{citnum}";
    preamble += "\n\\def\\oldbibitem{} \\let\\oldbibitem=\\bibitem";
    preamble += "\n\\def\\bibitem{\\stepcounter{citnum}\\oldbibitem}";
    const paragraphIndent = this.settings.getParagraphIndent();
    preamble += `
\\setlength{\\parindent}{${paragraphIndent}pt}`;
    const margin = this.settings.getMargin();
    if (margin) {
      preamble += `
\\usepackage[margin=${margin}]{geometry}`;
    }
    preamble += "\n\\hypersetup{";
    preamble += "\n	colorlinks = true,";
    preamble += "\n	urlcolor = blue,";
    preamble += "\n	linkcolor = blue,";
    preamble += "\n	citecolor = blue";
    preamble += "\n}";
    preamble += "\n\\sethlcolor{yellow}";
    preamble += "\n\\setcounter{secnumdepth}{4}";
    preamble += "\n\\setlength{\\parskip}{7pt}";
    preamble += "\n\\let\\oldmarginpar\\marginpar";
    preamble += "\n\\renewcommand\\marginpar[1]{\\oldmarginpar{\\tiny #1}}";
    preamble += "\n\\newcommand{\\ignore}[1]{}";
    if (documentClass === "ifacconf") {
      preamble += "\n\\newcounter{part}";
      preamble += "\n\\counterwithin*{section}{part}";
    }
    return preamble;
  }
  /**
   * Génère le début du document
   */
  generateDocumentStart() {
    let start = "\\begin{document}";
    if (this.settings.getAllowDisplayBreaks()) {
      start += "\n\\allowdisplaybreaks";
    }
    const author = this.settings.getAuthor();
    if (author) {
      start += `
\\author{${author}}`;
    }
    const title = this.settings.getTitle();
    if (title) {
      start += `
\\title{${title}}`;
      start += "\n\\maketitle";
    }
    return start;
  }
  /**
   * Traite le contenu principal
   */
  processMainContent(lines) {
    let textBeforeFirstSection = "";
    let mainContent = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith("\\section")) {
        mainContent = lines.slice(i).join("\n");
        break;
      } else {
        textBeforeFirstSection += line + "\n";
      }
    }
    if (textBeforeFirstSection.trim()) {
      mainContent = textBeforeFirstSection + mainContent;
    }
    if (this.settings.getAddTableOfContents()) {
      mainContent = "\\tableofcontents\n\\newpage\n\n" + mainContent;
    }
    return mainContent;
  }
  /**
   * Génère la fin du document
   */
  generateDocumentEnd() {
    let end = "";
    if (this.settings.getAddNewPageBeforeBibliography()) {
      end += "\n\\newpage\n\n";
    }
    end += "\n\\bibliographystyle{apacite}";
    end += "\n\\bibliography{BIBTEX}";
    end += "\n\\end{document}";
    return end;
  }
  /**
   * Génère les packages à charger selon les paramètres
   */
  generatePackages() {
    const packages = [];
    packages.push("\\usepackage[table]{xcolor}");
    packages.push("\\usepackage{tabularx}");
    packages.push("\\usepackage{longtable}");
    packages.push("\\usepackage{tabularray}");
    const documentClass = this.settings.getDocumentClass();
    if (documentClass === "ifacconf") {
      packages.push("%\u{1F480}\\usepackage{ifacconf}");
    }
    packages.push("\\usepackage{enumitem,amssymb}");
    packages.push("\\usepackage{hyperref}");
    packages.push("\\usepackage{geometry}");
    packages.push("\\usepackage{cleveref}");
    return packages.join("\n");
  }
  /**
   * Génère la configuration des hyperliens
   */
  generateHyperlinkSetup() {
    return `\\hypersetup{
	colorlinks = true,
	urlcolor = blue,
	linkcolor = blue,
	citecolor = blue
}`;
  }
  /**
   * Génère la configuration des marges
   */
  generateMarginSetup() {
    const margin = this.settings.getMargin();
    if (margin) {
      return `\\usepackage[margin=${margin}]{geometry}`;
    }
    return "";
  }
  /**
   * Génère la configuration des paragraphes
   */
  generateParagraphSetup() {
    const indent = this.settings.getParagraphIndent();
    return `\\setlength{\\parindent}{${indent}pt}`;
  }
};

// src/converter/LatexConverter.ts
var LatexConverter = class {
  constructor(app, settings, pathManager) {
    this.app = app;
    this.settings = settings;
    this.pathManager = pathManager;
    this.markdownProcessor = new MarkdownProcessor(this.app, this.settings);
    this.equationProcessor = new EquationProcessor(this.app, this.settings);
    this.tableProcessor = new TableProcessor(this.app, this.settings);
    this.referenceProcessor = new ReferenceProcessor(this.app, this.settings);
    this.latexGenerator = new LatexGenerator(this.app, this.settings, this.pathManager);
  }
  /**
   * Convertit une note en LaTeX
   */
  async convertNoteToLatex(file) {
    try {
      new import_obsidian.Notice("D\xE9but de la conversion en LaTeX...");
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let processedLines = await this.markdownProcessor.process(lines);
      processedLines = await this.equationProcessor.process(processedLines);
      processedLines = await this.tableProcessor.process(processedLines);
      processedLines = await this.referenceProcessor.process(processedLines);
      const latexContent = await this.latexGenerator.generate(processedLines, file);
      const texFilePath = this.getTexFilePath(file);
      await this.saveTexFile(texFilePath, latexContent);
      new import_obsidian.Notice(`Conversion r\xE9ussie ! Fichier cr\xE9\xE9: ${texFilePath}`);
      if (this.settings.getAutoCompile()) {
        await this.compileLatexToPdf(texFilePath);
      }
    } catch (error) {
      console.error("Erreur lors de la conversion:", error);
      new import_obsidian.Notice(`Erreur lors de la conversion: ${error.message}`);
    }
  }
  /**
   * Affiche une modale pour sélectionner une note à convertir
   */
  async showNoteSelectionModal() {
    new NoteSelectionModal(this.app, this).open();
  }
  /**
   * Compile le LaTeX en PDF
   */
  async compileLatexToPdf(texFilePath) {
    try {
      new import_obsidian.Notice("Compilation LaTeX en cours...");
      if (!texFilePath) {
        const writingPath = this.pathManager.getWritingPath();
        const texFiles = await this.findTexFiles(writingPath);
        if (texFiles.length === 0) {
          throw new Error("Aucun fichier .tex trouv\xE9");
        }
        texFilePath = texFiles[0];
      }
      const result = await this.compileLatex(texFilePath);
      if (result.success) {
        new import_obsidian.Notice("Compilation r\xE9ussie ! PDF g\xE9n\xE9r\xE9.");
      } else {
        throw new Error(`Erreur de compilation: ${result.error}`);
      }
    } catch (error) {
      console.error("Erreur lors de la compilation:", error);
      new import_obsidian.Notice(`Erreur lors de la compilation: ${error.message}`);
    }
  }
  /**
   * Lance un test complet du système
   */
  async runCompleteTest() {
    try {
      new import_obsidian.Notice("Lancement du test complet...");
      await this.testPaths();
      const testFile = await this.findTestFile();
      if (testFile) {
        await this.convertNoteToLatex(testFile);
      }
      await this.compileLatexToPdf();
      new import_obsidian.Notice("Test complet r\xE9ussi !");
    } catch (error) {
      console.error("Erreur lors du test complet:", error);
      new import_obsidian.Notice(`Erreur lors du test complet: ${error.message}`);
    }
  }
  /**
   * Obtient le chemin du fichier .tex correspondant
   */
  getTexFilePath(file) {
    const baseName = this.pathManager.getBasename(file.path);
    const writingPath = this.pathManager.getWritingPath();
    return this.pathManager.joinPaths(writingPath, `${baseName}.tex`);
  }
  /**
   * Sauvegarde le fichier .tex
   */
  async saveTexFile(filePath, content) {
    const dir = this.pathManager.getDirectory(filePath);
    await this.pathManager.ensureDirectory(dir);
    await this.app.vault.adapter.write(filePath, content);
  }
  /**
   * Trouve les fichiers .tex dans un répertoire
   */
  async findTexFiles(dirPath) {
    try {
      const files = await this.app.vault.adapter.list(dirPath);
      return files.files.filter((file) => file.endsWith(".tex")).map((file) => this.pathManager.joinPaths(dirPath, file)).sort((a, b) => {
        return 0;
      });
    } catch (error) {
      console.error("Erreur lors de la recherche de fichiers .tex:", error);
      return [];
    }
  }
  /**
   * Compile un fichier LaTeX
   */
  async compileLatex(texFilePath) {
    console.log(`Compilation de ${texFilePath}`);
    return { success: true };
  }
  /**
   * Test des chemins
   */
  async testPaths() {
    const paths = [
      this.pathManager.getWritingPath(),
      this.pathManager.getAutomationsPath(),
      this.pathManager.getLiteraturePath(),
      this.pathManager.getEquationBlocksPath(),
      this.pathManager.getTableBlocksPath()
    ];
    for (const path2 of paths) {
      await this.pathManager.ensureDirectory(path2);
    }
  }
  /**
   * Trouve un fichier de test
   */
  async findTestFile() {
    const files = this.app.vault.getMarkdownFiles();
    const testFiles = files.filter(
      (file) => file.path.includes("\u270DWriting") && !file.path.includes("\u{1F468}\u200D\u{1F4BB}")
    );
    return testFiles.length > 0 ? testFiles[0] : null;
  }
};
var NoteSelectionModal = class extends import_obsidian.SuggestModal {
  constructor(app, converter) {
    super(app);
    this.converter = converter;
  }
  getSuggestions(query) {
    const files = this.app.vault.getMarkdownFiles();
    return files.filter(
      (file) => file.path.toLowerCase().includes(query.toLowerCase()) && file.path.includes("\u270DWriting")
    );
  }
  renderSuggestion(file, el) {
    el.createEl("div", { text: file.basename });
    el.createEl("small", { text: file.path });
  }
  async onChooseSuggestion(file, evt) {
    await this.converter.convertNoteToLatex(file);
  }
};

// src/utils/PathManager.ts
var import_obsidian2 = require("obsidian");
var path = __toESM(require("path"));
var PathManager = class {
  constructor(app) {
    this.app = app;
    if (app.vault.adapter instanceof import_obsidian2.FileSystemAdapter) {
      this.vaultPath = app.vault.adapter.getBasePath();
    } else {
      throw new Error("L'adapter du vault n'est pas FileSystemAdapter, impossible de r\xE9cup\xE9rer le chemin absolu du vault.");
    }
  }
  /**
   * Normalise un chemin pour être compatible cross-platform
   */
  normalizePath(inputPath) {
    return path.normalize(inputPath);
  }
  /**
   * Joint des chemins de manière cross-platform
   */
  joinPaths(...paths) {
    return path.join(...paths);
  }
  /**
   * Obtient le chemin absolu du vault
   */
  getVaultPath() {
    return this.vaultPath;
  }
  /**
   * Obtient le chemin absolu d'un fichier
   */
  getAbsolutePath(relativePath) {
    return path.resolve(this.vaultPath, relativePath);
  }
  /**
   * Vérifie si un chemin est absolu
   */
  isAbsolutePath(inputPath) {
    return path.isAbsolute(inputPath);
  }
  /**
   * Obtient le répertoire d'un fichier
   */
  getDirectory(filePath) {
    return path.dirname(filePath);
  }
  /**
   * Obtient le nom de fichier sans extension
   */
  getBasename(filePath) {
    return path.basename(filePath, path.extname(filePath));
  }
  /**
   * Obtient l'extension d'un fichier
   */
  getExtension(filePath) {
    return path.extname(filePath);
  }
  /**
   * Construit le chemin vers le dossier Writing
   */
  getWritingPath() {
    return this.joinPaths(this.vaultPath, "\u270DWriting");
  }
  /**
   * Construit le chemin vers le dossier Automations
   */
  getAutomationsPath() {
    return this.joinPaths(this.vaultPath, "\u{1F468}\u200D\u{1F4BB}Automations");
  }
  /**
   * Construit le chemin vers le dossier Literature
   */
  getLiteraturePath() {
    return this.joinPaths(this.vaultPath, "\u{1F4DA}Literature");
  }
  /**
   * Construit le chemin vers les blocs d'équations
   */
  getEquationBlocksPath() {
    return this.joinPaths(this.getWritingPath(), "equation blocks");
  }
  /**
   * Construit le chemin vers les blocs de tableaux
   */
  getTableBlocksPath() {
    return this.joinPaths(this.getWritingPath(), "table blocks");
  }
  /**
   * Obtient le chemin d'un fichier TFile
   */
  getFilePath(file) {
    if (this.app.vault.adapter instanceof import_obsidian2.FileSystemAdapter) {
      return this.app.vault.adapter.getFullPath(file.path);
    } else {
      throw new Error("L'adapter du vault n'est pas FileSystemAdapter, impossible de r\xE9cup\xE9rer le chemin absolu du fichier.");
    }
  }
  /**
   * Vérifie si un fichier existe
   */
  async fileExists(filePath) {
    try {
      await this.app.vault.adapter.stat(filePath);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Crée un répertoire s'il n'existe pas
   */
  async ensureDirectory(dirPath) {
    try {
      await this.app.vault.adapter.mkdir(dirPath);
    } catch (error) {
      console.log(`R\xE9pertoire ${dirPath} existe d\xE9j\xE0 ou erreur:`, error);
    }
  }
  /**
   * Obtient le séparateur de chemin pour la plateforme
   */
  getPathSeparator() {
    return path.sep;
  }
  /**
   * Convertit un chemin Windows en format Unix si nécessaire
   */
  toUnixPath(inputPath) {
    return inputPath.replace(/\\/g, "/");
  }
  /**
   * Convertit un chemin Unix en format Windows si nécessaire
   */
  toWindowsPath(inputPath) {
    return inputPath.replace(/\//g, "\\");
  }
};

// src/settings/SettingsManager.ts
var DEFAULT_SETTINGS = {
  // Paramètres de base
  documentClass: "extarticle",
  fontSize: "",
  author: "Auteur",
  title: "",
  margin: "0.9in",
  // Paramètres de paragraphe
  paragraphIndent: 0,
  addTableOfContents: true,
  addNewPageBeforeBibliography: true,
  allowDisplayBreaks: true,
  // Paramètres de figures
  reduceSpacingBetweenFigures: false,
  putFigureBelowText: true,
  includePath: true,
  // Paramètres de références
  convertNonEmbeddedReferences: true,
  treatEquationBlocksSeparately: true,
  adaptSectionHierarchy: true,
  // Paramètres de liens internes
  addSectionNumberAfterReferencing: true,
  // Paramètres de tableaux
  tablePackage: "tabularx",
  tableAlignment: "center",
  tableRelWidth: 1.2,
  // Paramètres de compilation
  latexCompiler: "pdflatex",
  autoCompile: true,
  // Chemins (seront définis dynamiquement)
  writingPath: "",
  automationsPath: "",
  literaturePath: "",
  equationBlocksPath: "",
  tableBlocksPath: ""
};
var SettingsManager = class {
  constructor() {
    this.settings = DEFAULT_SETTINGS;
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS };
  }
  async saveSettings() {
    console.log("Sauvegarde des param\xE8tres:", this.settings);
  }
  getSettings() {
    return { ...this.settings };
  }
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
  }
  // Getters pour les paramètres spécifiques
  getDocumentClass() {
    return this.settings.documentClass;
  }
  getFontSize() {
    return this.settings.fontSize;
  }
  getAuthor() {
    return this.settings.author;
  }
  getTitle() {
    return this.settings.title;
  }
  getMargin() {
    return this.settings.margin;
  }
  getParagraphIndent() {
    return this.settings.paragraphIndent;
  }
  getAddTableOfContents() {
    return this.settings.addTableOfContents;
  }
  getAddNewPageBeforeBibliography() {
    return this.settings.addNewPageBeforeBibliography;
  }
  getAllowDisplayBreaks() {
    return this.settings.allowDisplayBreaks;
  }
  getReduceSpacingBetweenFigures() {
    return this.settings.reduceSpacingBetweenFigures;
  }
  getPutFigureBelowText() {
    return this.settings.putFigureBelowText;
  }
  getIncludePath() {
    return this.settings.includePath;
  }
  getConvertNonEmbeddedReferences() {
    return this.settings.convertNonEmbeddedReferences;
  }
  getTreatEquationBlocksSeparately() {
    return this.settings.treatEquationBlocksSeparately;
  }
  getAdaptSectionHierarchy() {
    return this.settings.adaptSectionHierarchy;
  }
  getAddSectionNumberAfterReferencing() {
    return this.settings.addSectionNumberAfterReferencing;
  }
  getTablePackage() {
    return this.settings.tablePackage;
  }
  getTableAlignment() {
    return this.settings.tableAlignment;
  }
  getTableRelWidth() {
    return this.settings.tableRelWidth;
  }
  getLatexCompiler() {
    return this.settings.latexCompiler;
  }
  getAutoCompile() {
    return this.settings.autoCompile;
  }
  // Méthodes pour mettre à jour les chemins
  setWritingPath(path2) {
    this.settings.writingPath = path2;
  }
  setAutomationsPath(path2) {
    this.settings.automationsPath = path2;
  }
  setLiteraturePath(path2) {
    this.settings.literaturePath = path2;
  }
  setEquationBlocksPath(path2) {
    this.settings.equationBlocksPath = path2;
  }
  setTableBlocksPath(path2) {
    this.settings.tableBlocksPath = path2;
  }
};

// src/settings/LatexSettingsTab.ts
var import_obsidian3 = require("obsidian");
var LatexSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Param\xE8tres LaTeX" });
    this.createBasicSettingsSection(containerEl);
    this.createParagraphSettingsSection(containerEl);
    this.createFigureSettingsSection(containerEl);
    this.createReferenceSettingsSection(containerEl);
    this.createTableSettingsSection(containerEl);
    this.createCompilationSettingsSection(containerEl);
  }
  createBasicSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de base" });
    new import_obsidian3.Setting(containerEl).setName("Classe de document").setDesc("Classe LaTeX \xE0 utiliser").addDropdown((dropdown) => dropdown.addOption("extarticle", "Article \xE9tendu").addOption("article", "Article standard").addOption("ifacconf", "Conf\xE9rence IFAC").setValue(this.plugin.settings.getDocumentClass()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ documentClass: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Taille de police").setDesc("Taille de police (ex: 12pt, 11pt)").addText((text) => text.setPlaceholder("12pt").setValue(this.plugin.settings.getFontSize()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ fontSize: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auteur").setDesc("Nom de l'auteur").addText((text) => text.setPlaceholder("Votre nom").setValue(this.plugin.settings.getAuthor()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ author: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Titre").setDesc("Titre du document").addText((text) => text.setPlaceholder("Titre du document").setValue(this.plugin.settings.getTitle()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ title: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Marges").setDesc("Marges de page (ex: 0.9in)").addText((text) => text.setPlaceholder("0.9in").setValue(this.plugin.settings.getMargin()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ margin: value });
      await this.plugin.settings.saveSettings();
    }));
  }
  createParagraphSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de paragraphe" });
    new import_obsidian3.Setting(containerEl).setName("Indentation premi\xE8re ligne").setDesc("Indentation en points (0 pour aucune)").addSlider((slider) => slider.setLimits(0, 50, 5).setValue(this.plugin.settings.getParagraphIndent()).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.updateSettings({ paragraphIndent: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Table des mati\xE8res").setDesc("Ajouter une table des mati\xE8res").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAddTableOfContents()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ addTableOfContents: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Nouvelle page avant bibliographie").setDesc("Ins\xE9rer une nouvelle page avant la bibliographie").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAddNewPageBeforeBibliography()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ addNewPageBeforeBibliography: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Autoriser les sauts de page").setDesc("Autoriser les sauts de page dans les \xE9quations").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAllowDisplayBreaks()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ allowDisplayBreaks: value });
      await this.plugin.settings.saveSettings();
    }));
  }
  createFigureSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de figures" });
    new import_obsidian3.Setting(containerEl).setName("R\xE9duire l'espacement entre figures").setDesc("R\xE9duire l'espacement entre les figures").addToggle((toggle) => toggle.setValue(this.plugin.settings.getReduceSpacingBetweenFigures()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ reduceSpacingBetweenFigures: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Figure sous le texte").setDesc("Placer les figures sous le texte").addToggle((toggle) => toggle.setValue(this.plugin.settings.getPutFigureBelowText()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ putFigureBelowText: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Inclure le chemin").setDesc("Inclure le chemin complet des images").addToggle((toggle) => toggle.setValue(this.plugin.settings.getIncludePath()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ includePath: value });
      await this.plugin.settings.saveSettings();
    }));
  }
  createReferenceSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de r\xE9f\xE9rences" });
    new import_obsidian3.Setting(containerEl).setName("Convertir les r\xE9f\xE9rences non-embarqu\xE9es").setDesc("Convertir [[note]] en texte simple").addToggle((toggle) => toggle.setValue(this.plugin.settings.getConvertNonEmbeddedReferences()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ convertNonEmbeddedReferences: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Traiter les blocs d'\xE9quations s\xE9par\xE9ment").setDesc("Traiter les blocs d'\xE9quations de mani\xE8re s\xE9par\xE9e").addToggle((toggle) => toggle.setValue(this.plugin.settings.getTreatEquationBlocksSeparately()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ treatEquationBlocksSeparately: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Adapter la hi\xE9rarchie des sections").setDesc("Adapter la hi\xE9rarchie des sections dans les notes embarqu\xE9es").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAdaptSectionHierarchy()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ adaptSectionHierarchy: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Num\xE9ro de section apr\xE8s r\xE9f\xE9rence").setDesc("Ajouter le num\xE9ro de section apr\xE8s les r\xE9f\xE9rences internes").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAddSectionNumberAfterReferencing()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ addSectionNumberAfterReferencing: value });
      await this.plugin.settings.saveSettings();
    }));
  }
  createTableSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de tableaux" });
    new import_obsidian3.Setting(containerEl).setName("Package de tableau").setDesc("Package LaTeX pour les tableaux").addDropdown((dropdown) => dropdown.addOption("tabularx", "tabularx").addOption("longtable", "longtable").addOption("tabularray", "tabularray").setValue(this.plugin.settings.getTablePackage()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ tablePackage: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Alignement des tableaux").setDesc("Alignement par d\xE9faut des tableaux").addDropdown((dropdown) => dropdown.addOption("center", "Centr\xE9").addOption("left", "Gauche").addOption("right", "Droite").setValue(this.plugin.settings.getTableAlignment()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ tableAlignment: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Largeur relative des tableaux").setDesc("Largeur relative des tableaux (1.0 = 100%)").addSlider((slider) => slider.setLimits(0.5, 2, 0.1).setValue(this.plugin.settings.getTableRelWidth()).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.updateSettings({ tableRelWidth: value });
      await this.plugin.settings.saveSettings();
    }));
  }
  createCompilationSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Param\xE8tres de compilation" });
    new import_obsidian3.Setting(containerEl).setName("Compilateur LaTeX").setDesc("Compilateur LaTeX \xE0 utiliser").addDropdown((dropdown) => dropdown.addOption("pdflatex", "pdflatex").addOption("xelatex", "xelatex").addOption("lualatex", "lualatex").setValue(this.plugin.settings.getLatexCompiler()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ latexCompiler: value });
      await this.plugin.settings.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Compilation automatique").setDesc("Compiler automatiquement apr\xE8s conversion").addToggle((toggle) => toggle.setValue(this.plugin.settings.getAutoCompile()).onChange(async (value) => {
      this.plugin.settings.updateSettings({ autoCompile: value });
      await this.plugin.settings.saveSettings();
    }));
  }
};

// src/main.ts
var StraightforwardObsidian2LatexPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("Chargement du plugin Straightforward Obsidian2Latex");
    this.pathManager = new PathManager(this.app);
    this.settings = new SettingsManager();
    this.converter = new LatexConverter(this.app, this.settings, this.pathManager);
    await this.settings.loadSettings();
    this.addCommands();
    this.addSettingTab(new LatexSettingsTab(this.app, this));
  }
  onunload() {
    console.log("D\xE9chargement du plugin Straightforward Obsidian2Latex");
  }
  addCommands() {
    this.addCommand({
      id: "convert-current-note-to-latex",
      name: "Convertir la note actuelle en LaTeX",
      editorCallback: async (editor, ctx) => {
        const file = ctx.file;
        if (file) {
          await this.converter.convertNoteToLatex(file);
        }
      }
    });
    this.addCommand({
      id: "convert-specific-note-to-latex",
      name: "Convertir une note sp\xE9cifique en LaTeX",
      callback: async () => {
        await this.converter.showNoteSelectionModal();
      }
    });
    this.addCommand({
      id: "compile-latex-to-pdf",
      name: "Compiler le LaTeX en PDF",
      callback: async () => {
        await this.converter.compileLatexToPdf();
      }
    });
    this.addCommand({
      id: "run-complete-test",
      name: "Lancer le test complet",
      callback: async () => {
        await this.converter.runCompleteTest();
      }
    });
    this.addCommand({
      id: "open-latex-settings",
      name: "Ouvrir les param\xE8tres LaTeX",
      callback: () => {
        if (this.app.setting && typeof this.app.setting.openTabById === "function") {
          this.app.setting.openTabById(this.manifest.id);
        } else {
          console.warn("Impossible d'ouvrir le panneau de param\xE8tres automatiquement sur cette version d'Obsidian.");
        }
      }
    });
  }
};
