import type { LexerToken, LiteralToken, NumberToken, PunctuatorToken, StringToken, WhitespaceToken } from 'json-lexer';
/**
 * Extends token type with the source JSON string offset of each token
 */
export declare type TokenWithOffset<TokenType extends LexerToken = LexerToken> = TokenType & {
    offset: number;
};
export declare type TokensWithOffset = TokenWithOffset[];
export interface CstTokenRange {
    start: number;
    end: number;
}
export declare type CstKindLiteral = 'literal';
export declare type CstKindNumber = 'number';
export declare type CstKindString = 'string';
export declare type CstKindObjectPropertyColon = 'object-property-colon';
export declare type CstKindObjectProperty = 'object-property';
export declare type CstKindObject = 'object';
export declare type CstKindArrayElement = 'array-element';
export declare type CstKindArray = 'array';
export declare type CstKind = CstKindLiteral | CstKindNumber | CstKindString | CstKindObjectPropertyColon | CstKindObjectProperty | CstKindObject | CstKindArrayElement | CstKindArray;
export interface CstNodeLiteral {
    kind: CstKindLiteral;
    range: CstTokenRange;
    token: TokenWithOffset<LiteralToken>;
}
export interface CstNodeNumber {
    kind: CstKindNumber;
    range: CstTokenRange;
    token: TokenWithOffset<NumberToken>;
}
export interface CstNodeString {
    kind: CstKindString;
    range: CstTokenRange;
    token: TokenWithOffset<StringToken>;
}
export interface CstNodeObjectPropertyColon {
    kind: CstKindObjectPropertyColon;
    range: CstTokenRange;
    whitespaceBefore?: TokenWithOffset<WhitespaceToken>;
    punctuatorToken?: TokenWithOffset<PunctuatorToken>;
    whitespaceAfter?: TokenWithOffset<WhitespaceToken>;
}
export interface CstNodeObjectProperty {
    kind: CstKindObjectProperty;
    range: CstTokenRange;
    whitespaceBefore?: TokenWithOffset<WhitespaceToken>;
    keyToken: TokenWithOffset<StringToken>;
    key: string;
    colon: CstNodeObjectPropertyColon;
    valueTokens: TokensWithOffset;
    whitespaceBeforeComma?: TokenWithOffset<WhitespaceToken>;
    comma?: TokenWithOffset<PunctuatorToken>;
    valueNode: CstValueNode;
}
export interface CstNodeObject {
    kind: CstKindObject;
    range: CstTokenRange;
    children: CstNodeObjectProperty[];
    whitespaceAfterChildren?: TokenWithOffset<WhitespaceToken>;
}
export interface CstNodeArrayElement {
    kind: CstKindArrayElement;
    range: CstTokenRange;
    whitespaceBefore?: TokenWithOffset<WhitespaceToken>;
    valueTokens: TokensWithOffset;
    whitespaceBeforeComma?: TokenWithOffset<WhitespaceToken>;
    comma?: TokenWithOffset<PunctuatorToken>;
    valueNode: CstValueNode;
}
export interface CstNodeArray {
    kind: CstKindArray;
    range: CstTokenRange;
    children: CstNodeArrayElement[];
    whitespaceAfterChildren?: TokenWithOffset<WhitespaceToken>;
}
export declare type CstValueNode = CstNodeLiteral | CstNodeNumber | CstNodeString | CstNodeObject | CstNodeArray;
export declare type CstNode = CstValueNode | CstNodeObjectProperty | CstNodeObjectPropertyColon | CstNodeArrayElement;
export interface CstDocument {
    whitespaceBefore?: TokenWithOffset<WhitespaceToken>;
    valueTokens: TokensWithOffset;
    whitespaceAfter?: TokenWithOffset<WhitespaceToken>;
    root: CstValueNode;
}
