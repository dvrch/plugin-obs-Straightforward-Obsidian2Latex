var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/messages.ts
var WarningID = /* @__PURE__ */ ((WarningID2) => {
  WarningID2["NoMinAppVersion"] = "no-min-app-version";
  WarningID2["NoName"] = "no-name";
  WarningID2["NoIsDesktopOnly"] = "no-is-desktop-only";
  WarningID2["MissingVersionsFile"] = "missing-versions-file";
  WarningID2["OverriddenVersion"] = "overridden-version";
  return WarningID2;
})(WarningID || {});
var ErrorID = /* @__PURE__ */ ((ErrorID2) => {
  ErrorID2["NoDescription"] = "no-description";
  ErrorID2["NoAuthor"] = "no-author";
  ErrorID2["InvalidVersionsFile"] = "invalid-versions-file";
  return ErrorID2;
})(ErrorID || {});
function warnNoMinAppVersion(packageJson, detected) {
  const pos = packageJson.tryPos(".obsidian");
  return {
    id: "no-min-app-version" /* NoMinAppVersion */,
    text: "No minimum Obsidian version is specified.",
    detail: `A default value of "${detected}" (the dependency version) is being used.`,
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: (pos == null ? void 0 : pos.prop) === ".obsidian" ? "Add `minAppVersion` under the `obsidian` object." : "Add an `obsidian` object, then add `minAppVersion` under it."
    })
  };
}
function warnNoName(packageJson, defaultValue) {
  const pos = packageJson.tryPos(".obsidian");
  return {
    id: "no-name" /* NoName */,
    text: `No plugin name is provided.`,
    detail: `A default value of "${defaultValue}" (the package name) is being used.`,
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: (pos == null ? void 0 : pos.prop) === ".obsidian" ? "Add `name` under the `obsidian` object." : "Add an `obsidian` object, then add `name` under it."
    })
  };
}
function warnNoIsDesktopOnly(packageJson, defaultValue) {
  const pos = packageJson.tryPos(".obsidian");
  return {
    id: "no-is-desktop-only" /* NoIsDesktopOnly */,
    text: `No \`isDesktopOnly\` value was specified.`,
    detail: `A default value of ${defaultValue} is being used.`,
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: (pos == null ? void 0 : pos.prop) === ".obsidian" ? "Add `isDesktopOnly` under the `obsidian` object." : "Add an `obsidian` object, then add `isDesktopOnly` under it."
    })
  };
}
function errNoDescription(packageJson) {
  const pos = packageJson.tryPos(".");
  return {
    id: "no-description" /* NoDescription */,
    text: "No plugin description was provided.",
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: "Add a `description` to the package.json file."
    })
  };
}
function errNoAuthor(packageJson) {
  const pos = packageJson.tryPos(".");
  return {
    id: "no-author" /* NoAuthor */,
    text: "No plugin author was provided.",
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: "Add an `author` to the package.json file."
    })
  };
}
function warnOverriddenVersion(packageJson) {
  const pos = packageJson.tryPos(".obsidian.version");
  return {
    id: "overridden-version" /* OverriddenVersion */,
    text: "The plugin version does not follow the package verison.",
    detail: "The value is being overridden under the `obsidian` object in your package.json.",
    location: __spreadProps(__spreadValues({}, pos == null ? void 0 : pos.result), {
      suggestion: `If this is intentional, add \`ignoreWarning: ["${"overridden-version" /* OverriddenVersion */}"]\` to the plugin options.`
    })
  };
}
function warnMissingVersionsFile(file) {
  return {
    id: "missing-versions-file" /* MissingVersionsFile */,
    text: "There is no `versions.json` file. One will be created.",
    detail: `Could not stat file at "${file}".`
  };
}
function errInvalidVersionsFile(file, err) {
  return {
    id: "invalid-versions-file" /* InvalidVersionsFile */,
    text: "The `versions.json` file is invalid.",
    detail: err.message
  };
}

// src/plugin.ts
import { readFile as readFile2, writeFile } from "fs/promises";
import { dirname as dirname2 } from "path";
import { env } from "process";

// src/package-json.ts
import { jsonpos } from "jsonpos";
var PackageJson = class {
  constructor(file, text) {
    this.file = file;
    this.text = text;
    this.textLines = text.split("\n");
    this.data = JSON.parse(text);
  }
  /**
   * Gets the position and text of a property within this `package.json` file.
   *
   * @param propPath The property path.
   * @returns The position, or null if not found.
   */
  pos(propPath) {
    try {
      const loc = jsonpos(this.text, { dotPath: propPath, markIdentifier: true });
      if (loc.start == null || loc.end == null)
        return null;
      return {
        file: this.file,
        line: loc.start.line,
        column: loc.start.column - 1,
        length: loc.end.offset - loc.start.offset,
        lineText: this.textLines[loc.start.line - 1]
      };
    } catch (ex) {
      return null;
    }
  }
  /**
   * Gets the position and text of a property within this `package.json` file.
   * If the specific property cannot be a found, one of its parents will be returned instead.
   *
   * @param propPath The property path.
   * @returns The position, or null if not found.
   */
  tryPos(propPath) {
    const parts = propPath.split(".");
    while (parts.length > 1) {
      const prop2 = parts.join(".");
      const result2 = this.pos(prop2);
      if (result2 != null)
        return { prop: prop2, result: result2 };
      parts.pop();
    }
    const prop = parts[0] === "" ? "." : parts[0];
    const result = this.pos(prop);
    if (result != null)
      return { prop, result };
    return null;
  }
};
function parsePersonString(person) {
  const REGEX_EMAIL_FIELD = /\s<([^>]*@[^>]*)>/;
  const REGEX_URL_FIELD = /\s\(([^)]+)\)/;
  let email = null;
  let url = null;
  const match_email = REGEX_EMAIL_FIELD.exec(person);
  if (match_email != null) {
    email = match_email[1];
    person = person.substring(0, match_email.index) + person.substring(match_email.index + match_email[0].length);
  }
  const match_url = REGEX_URL_FIELD.exec(person);
  if (match_url != null) {
    url = match_url[1];
    person = person.substring(0, match_url.index) + person.substring(match_url.index + match_url[0].length);
  }
  return {
    name: person.trim(),
    email,
    url
  };
}
function getAuthorName(packageJson) {
  if (packageJson.author == null)
    return null;
  if (typeof packageJson.author === "object")
    return packageJson.author.name;
  return parsePersonString(packageJson.author).name;
}
function getAuthorURL(packageJson) {
  var _a;
  if (packageJson.author == null)
    return null;
  if (typeof packageJson.author === "object")
    return (_a = packageJson.author.url) != null ? _a : null;
  return parsePersonString(packageJson.author).url;
}
function getFundingURL(packageJson) {
  var _a, _b;
  return (_b = (_a = packageJson.funding) == null ? void 0 : _a.url) != null ? _b : null;
}
function getObsidianDependencyVersion(packageJson) {
  if (packageJson.dependencies != null && packageJson.dependencies.obsidian != null) {
    return packageJson.dependencies.obsidian;
  }
  if (packageJson.devDependencies != null && packageJson.devDependencies.obsidian != null) {
    return packageJson.devDependencies.obsidian;
  }
  return null;
}

// src/generate-manifest.ts
function generateManifest(packageJson, options) {
  var _a, _b, _c;
  const WARNING = [];
  const ERROR = [];
  const packageData = packageJson.data;
  const authorUrl = getAuthorURL(packageData);
  const fundingUrl = getFundingURL(packageData);
  const author = getAuthorName(packageData);
  const description = (_a = packageData.description) != null ? _a : null;
  const minAppVersion = getObsidianDependencyVersion(packageData);
  const manifest = __spreadValues({
    id: packageData.name,
    version: packageData.version
  }, (_b = packageData.obsidian) != null ? _b : {});
  if (manifest.name == null) {
    WARNING.push(warnNoName(packageJson, packageData.name));
    manifest.name = packageData.name;
  }
  if (manifest.description == null) {
    if (description != null) {
      manifest.description = description;
    } else {
      ERROR.push(errNoDescription(packageJson));
    }
  }
  if (manifest.author == null) {
    if (author != null) {
      manifest.author = author;
    } else {
      ERROR.push(errNoAuthor(packageJson));
    }
  }
  if (manifest.minAppVersion == null) {
    const warning = warnNoMinAppVersion(packageJson, minAppVersion);
    (minAppVersion == null ? ERROR : WARNING).push(warning);
    if (minAppVersion != null) {
      manifest.minAppVersion = minAppVersion;
    }
  }
  if (manifest.isDesktopOnly == null) {
    WARNING.push(warnNoIsDesktopOnly(packageJson, false));
    manifest.isDesktopOnly = false;
  }
  if (manifest.authorUrl == null && authorUrl != null)
    manifest.authorUrl = authorUrl;
  if (manifest.fundingUrl == null && fundingUrl != null)
    manifest.fundingUrl = fundingUrl;
  if (((_c = packageData.obsidian) == null ? void 0 : _c.version) != null) {
    WARNING.push(warnOverriddenVersion(packageJson));
    manifest.isDesktopOnly = false;
  }
  return {
    manifest,
    errors: ERROR,
    warnings: WARNING
  };
}

// src/generate-versions.ts
import { readFile, stat } from "fs/promises";
function generateVersions(oldVersions, manifest, options) {
  const WARNING = [];
  const ERROR = [];
  const versions = __spreadValues({}, oldVersions);
  versions[manifest.version] = manifest.minAppVersion;
  return {
    versions,
    errors: ERROR,
    warnings: WARNING
  };
}
async function readVersions(file) {
  try {
    await stat(file);
  } catch (ex) {
    return {
      versions: {},
      warnings: [warnMissingVersionsFile(file)]
    };
  }
  try {
    const contents = JSON.parse(await readFile(file, "utf-8"));
    return {
      versions: contents
    };
  } catch (ex) {
    return {
      versions: null,
      errors: [errInvalidVersionsFile(file, ex instanceof Error ? ex : new Error(`${ex}`))]
    };
  }
}

// src/util.ts
import { access, mkdir } from "fs/promises";
import { dirname, join } from "path";
import { cwd } from "process";
function findPackageJsonFile(from) {
  const dir = from != null ? from : cwd();
  const paths = [];
  let current;
  for (current = dir; current !== dirname(current); current = dirname(current)) {
    paths.push(join(current, "package.json"));
  }
  paths.push(join(current, "package.json"));
  return new Promise((resolve, reject) => {
    let finished = false;
    const completed = new Array(paths.length).fill(false);
    const resolved = new Array(paths.length).fill(false);
    function maybeComplete() {
      if (finished)
        return;
      for (let i = 0; i < completed.length; i++) {
        if (completed[i] === false)
          return;
        if (resolved[i] === false)
          continue;
        finished = true;
        resolve(paths[i]);
        return;
      }
      reject(new Error("could not find tsconfig.json file"));
    }
    for (let i = 0; i < paths.length; i++) {
      access(paths[i]).then(() => resolved[i] = true).catch(() => resolved[i] = false).finally(() => completed[i] = true).finally(maybeComplete);
    }
    if (paths.length === 0) {
      maybeComplete();
    }
  });
}
async function ensureDir(path) {
  await mkdir(path, { recursive: true });
}

// src/plugin.ts
function obsidianPlugin(options) {
  var _a;
  const effectiveOptions = options != null ? options : {};
  const ignoredWarnings = new Set((_a = options == null ? void 0 : options.ignoreWarnings) != null ? _a : []);
  return {
    name: "obsidian",
    async setup(build) {
      var _a2, _b, _c, _d;
      const outVersionsFile = (_a2 = effectiveOptions.outVersionsFile) != null ? _a2 : "versions.json";
      const outManifestFile = (_b = effectiveOptions.outManifestFile) != null ? _b : "manifest.json";
      const packageJsonFile = (_d = (_c = effectiveOptions.packageJsonFile) != null ? _c : env["npm_package_json"]) != null ? _d : await findPackageJsonFile();
      if (packageJsonFile == null) {
        throw new Error("Unable to find package.json file.");
      }
      build.onStart(async () => {
        const packageJsonText = await readFile2(packageJsonFile, "utf8");
        const packageJson = new PackageJson(packageJsonFile, packageJsonText);
        const JOBS = [];
        const WARNING = [];
        const ERROR = [];
        let oldVersions;
        {
          const { versions, warnings, errors } = await readVersions(outVersionsFile);
          if (warnings != null)
            WARNING.push(...warnings);
          if (errors != null)
            ERROR.push(...errors);
          oldVersions = versions;
        }
        let manifest;
        {
          const { manifest: result, warnings, errors } = generateManifest(packageJson, effectiveOptions);
          if (warnings != null)
            WARNING.push(...warnings);
          if (errors != null)
            ERROR.push(...errors);
          manifest = result;
          JOBS.push(writeManifest(outManifestFile, manifest));
        }
        if (manifest != null && oldVersions != null) {
          const {
            versions: result,
            warnings,
            errors
          } = generateVersions(oldVersions, manifest, effectiveOptions);
          if (warnings != null)
            WARNING.push(...warnings);
          if (errors != null)
            ERROR.push(...errors);
          JOBS.push(writeVersions(outVersionsFile, result));
        }
        await Promise.all([JOBS]);
        return {
          warnings: WARNING.filter((w) => {
            var _a3;
            return !ignoredWarnings.has((_a3 = w.id) != null ? _a3 : "");
          }),
          errors: ERROR
        };
      });
    }
  };
}
async function writeManifest(outManifestFile, manifest) {
  if (manifest != null) {
    await ensureDir(dirname2(outManifestFile));
    await writeFile(outManifestFile, JSON.stringify(manifest, void 0, 2), "utf-8");
  }
}
async function writeVersions(outVersionsFile, versions) {
  if (versions != null) {
    await ensureDir(dirname2(outVersionsFile));
    await writeFile(outVersionsFile, JSON.stringify(versions, void 0, 2), "utf-8");
  }
}
export {
  ErrorID,
  WarningID,
  obsidianPlugin as default
};
